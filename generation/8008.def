//	Information from : 8008 Datasheet, Scelbi 8-H Users Manual Table 2.

// ***************************************************************************************************
//
//	@C 			Conditions for bits 3-5 : NC NZ P PO C Z M PE
//	@D 			Destination register A B C D E H L M from bits 3-5 of the opcode
//	@HL 		Short for (($H << 8) | $L)
//	@O 			Opcode as 2 digit hex value with 0x prefix
//	@P 			Port Address as 2 digit hex
//	@R 			RST Address as 2 digit hex
//	@S 			Source register A B C D E H L M from bits 0-2 of the opcode
//	@T 			Code that tests for the @C conditions
//
//	$prefix indicates identifier. So $PC would be PC for C, and this.pc for Javascript.
//
//	Functions:
//
//		$ADD(n,c)		8 bit add of A,n and c, carry updated as side effect,returns result
//		$FETCH()		Fetch instruction to MB, bump PC
//		$INPUT(p)		Read from port p, return result
//		$OUTPUT(p,d) 	Write to port p, data d
//		$PULL()			Pull PC off stack or rotate stack
//		$PUSH()			Push PC on stack or rotate stack
//		$READ() 		Read Memory(MA) to MB
//		$TOS()			Return top value on stack (rotate or pop)
//		$WRITE() 		Write MB to Memory(MA)
//		
//	Variables:
//		A,B,C,D,E,H,L 	CPU Registers
//		CARRY 			CPU Flag
//		PSZVALUE 		Value which represents state of P,S and Z flags.
//		HALT 			Halt flag, cleared by RUN/INT starting.
//		INTREQ 			Set to non zero when interrupt has been requested.
//		INTMODE 		Set to non zero when in int - single step, switch fetch, cleared end of instr
//		MA 				Memory Address
//		MB 				Memory Buffer
//		T16 			16 bit minimum work register
//
// ***************************************************************************************************
// 					Load Data from One CPU Register to Another CPU Register
// ***************************************************************************************************

C0-C6 	"MOV A,@S"	5
	1:		00		$PC:@O 				$A = $@S
C8-CE 	"MOV B,@S"	5
	1:		00		$PC:@O 				$B = $@S
D0-D6 	"MOV C,@S"	5
	1:		00		$PC:@O 				$C = $@S
D8-DE 	"MOV D,@S"	5
	1:		00		$PC:@O 				$D = $@S
E0-E6 	"MOV E,@S"	5
	1:		00		$PC:@O 				$E = $@S
E8-EE 	"MOV H,@S"	5
	1:		00		$PC:@O 				$H = $@S
F0-F6 	"MOV L,@S"	5
	1:		00		$PC:@O 				$L = $@S

// ***************************************************************************************************
//						Load Data from a CPU Register to a Location in memory
// ***************************************************************************************************

F8-FE 	"MOV M,@S"	7
	1:		** 		@HL:@O				$MA = @HL;$MB = $@S
	2:		00		$PC:$MB 			$WRITE();

// ***************************************************************************************************
//						Load Data from a Location in memory to a CPU Register
// ***************************************************************************************************

C7-F7,8 "MOV @D,M"	8
	1:		*0 		@HL:@O 				$MA = @HL;$READ()
	2:		00		$PC:$MB				$@D	= $MB

// ***************************************************************************************************
//								Load Immediate Data into a CPU Register
// ***************************************************************************************************

06-36,8 "MVI @D,%1"	8
	1:		*0		$PC:@O 				$FETCH()
	2:		00 		$PC:$MB 			$@D = $MB

// ***************************************************************************************************
//									Load Immediate Data into memory
// ***************************************************************************************************

3E 		"MVI M,%1"	9
	1:		*0 		$PC:@O 				$FETCH()
	2:		** 		@HL:$MB 			$MA = @HL
	3:		00 		$PC:$MB				$WRITE()

// ***************************************************************************************************
//							Increment or Decrement a CPU Register
// ***************************************************************************************************

08-30,8	"INR @D"	5
	1:		00 		$PC:@O 				$@D = ($@D+1) & 255;$PSZVALUE = $@D

09-31,8	"DCR @D"	5
	1:		00 		$PC:@O 				$@D = ($@D-1) & 255;$PSZVALUE = $@D

// ***************************************************************************************************
//				Arithmetic Instruction between the Accumulator and a CPU Register
// ***************************************************************************************************

80-86 	"ADD @S"	5	
	1:		00 		$PC:@O 				$A = $PSZVALUE = $ADD(@S,0)
88-8E 	"ADC @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $ADD(@S,$CARRY)
90-96 	"SUB @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $ADD(@S ^ 255,1)
98-9E 	"SBB @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $ADD(@S ^ 255,$CARRY ^ 1)

// ***************************************************************************************************
//						Compare between the Accumulator and a CPU Register
// ***************************************************************************************************

B8-BE 	"CMP @S"	5
	1:		00 		$PC:@O 				$PSZVALUE = $ADD(@S ^ 255,1)

// ***************************************************************************************************
//			Arithmetic or Compare Instruction between the Accumulator and a word in memory
// ***************************************************************************************************

87 		"ADD M"		8
	1:		*0 		@HL:@O  			$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $ADD($MB,0)
8F 		"ADC M"		8
	1:		*0 		@HL:@O  			$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $ADD($MB,$CARRY)
97 		"SUB M"		8
	1:		*0 		@HL:@O  			$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $ADD($MB ^ 255,1)
9F 		"SBB M"		8
	1:		*0 		@HL:@O  			$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $ADD($MB ^ 255,$CARRY ^ 1)
BF 		"CMP M"		8
	1:		*0 		@HL:@O  			$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$PSZVALUE = $ADD($MB ^ 255,1)

// ***************************************************************************************************
//					"Immediate" type Arithmetic or Compare Instructions
// ***************************************************************************************************

04 		"ADI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00		$PC:$MB				$A = $PSZVALUE = $ADD($MB,0)
0C 		"ACI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00		$PC:$MB				$A = $PSZVALUE = $ADD($MB,$CARRY)
14 		"SUI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00		$PC:$MB				$A = $PSZVALUE = $ADD($MB ^ 255,1)
1C 		"SBI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00		$PC:$MB				$A = $PSZVALUE = $ADD($MB ^ 255,$CARRY ^ 1)
3C 		"CPI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00		$PC:$MB				$PSZVALUE = $ADD($MB ^ 255,1)

// ***************************************************************************************************
//				Boolean Math Operations between Accumulator and CPU Registers
// ***************************************************************************************************

A0-A6 	"ANA @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $A & $@S;$CARRY = 0
A8-AE 	"XRA @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $A ^ $@S;$CARRY = 0
B0-B6 	"ORA @S"	5
	1:		00 		$PC:@O 				$A = $PSZVALUE = $A | $@S;$CARRY = 0

// ***************************************************************************************************
//				Boolean Math Operations between Accumulator and a location in memory
// ***************************************************************************************************

A7 		"ANA M"		8
	1:		*0 		@HL:@O 				$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A & $MB;$CARRY = 0
AF 		"XRA M"		8
	1:		*0 		@HL:@O 				$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A ^ $MB;$CARRY = 0
B7 		"ORA M"		8
	1:		*0 		@HL:@O 				$MA = @HL;$READ()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A | $MB;$CARRY = 0

// ***************************************************************************************************
//									Boolean Immediate Instructions
// ***************************************************************************************************

24 		"ANI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A & $MB;$CARRY = 0
2C 		"XRI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A ^ $MB;$CARRY = 0
34 		"ORI %1"	8
	1:		*0 		$PC:@O 				$FETCH()
	2:		00 		$PC:$MB 			$A = $PSZVALUE = $A | $MB;$CARRY = 0

// ***************************************************************************************************
//									Accumulator Rotate Instructions
// ***************************************************************************************************

02 		"RLC"		5					
	1: 		00 		$PC:@O 				$CARRY = ($A >> 7) & 1;$A = (($A << 1) & 0xFF) | $CARRY)
0A 		"RRC"		5 					
	1: 		00 		$PC:@O 				$CARRY = $A & 1;$A = ($A >> 1) | ($CARRY << 7)
12 		"RAL"		5    				
	1: 		00 		$PC:@O 				$T16 = ($A << 1)|$CARRY;$A = $T16 & 255;$CARRY = ($T16>>8) & 1
1A 		"RAR"		5 					
	1: 		00 		$PC:@O 				$T16 = $A|($CARRY << 8);$A = $T16 >> 1;$CARRY = $T16 & 1

// ***************************************************************************************************
//								Unconditional Jump or Call Instructions
// ***************************************************************************************************

44-7C,8 "JMP %2"	11
	1:		*0 		$PC:@O 				$FETCH();$T16 = $MB << 8
	2:		*0 		$PC:$MB 			$FETCH();$T16 = ($T16 | $MB) & 0x3FFF
	3:		00 		$T16:$MB 			$PC = $T16

46-7E,8 "CALL %2"	11
	1:		*0 		$PC:@O 				$FETCH();$T16 = $MB << 8
	2:		*0 		$PC:$MB 			$FETCH();$T16 = ($T16 | $MB) & 0x3FFF
	3:		00 		$T16:$MB 			$PUSH();$PC = $T16

// ***************************************************************************************************
//										Conditional Jump or Call
// ***************************************************************************************************

40-78,8 "J@C %2"	10
	1:		*0 		$PC:@O 				$FETCH();$T16 = $MB << 8
	2:		*0 		$PC:$MB 			$FETCH();$T16 = ($T16 | $MB) & 0x3FFF;if (@T) { $PC = $T16; }
	3:		00 		$PC:$MB 			;

42-7A,8 "C@C %2"	10
	1:		*0 		$PC:@O 				$FETCH();$T16 = $MB << 8
	2:		*0 		$PC:$MB 			$FETCH();$T16 = ($T16 | $MB) & 0x3FFF;if (@T) { $PUSH();$PC = $T16; }
	3:		00 		$PC:$MB 			;

// ***************************************************************************************************
//										Unconditional Return
// ***************************************************************************************************

07-3F,8	"RET"		5
	1: 		00  	$TOS():@O 			$PULL()

// ***************************************************************************************************
//										Conditional Return
// ***************************************************************************************************

03-3B,8	"R@C"		5
	1:		00 		((@T)?$TOS():$PC):@O if (@T) { $PULL(); }

// ***************************************************************************************************
//										Restart instruction
// ***************************************************************************************************

05-3D,8	"RST @R" 	5
	1: 		00 		$PC:0x@R 			$PUSH();$PC = 0x@R

// ***************************************************************************************************
//											Output Instruction
// ***************************************************************************************************

51-7F,2 "OUT @P"	6
	1:		0* 		(0x@P<<8)|$A:@O 	$OUTPUT(0x@P,$A)
	2:		00 		$PC:$A 				;

// ***************************************************************************************************
//											Input Instruction
// ***************************************************************************************************

41-4F,2	"IN @P"		8
	1:		0* 		(0x@P<<8)|$A:@O 	$A = $INPUT(0x@P)
	2:		00		$PC:$A 				;

// ***************************************************************************************************
//											Halt Instructions
// ***************************************************************************************************

00-01	"HLT"		4
	1: 		00 		$PC:@O 				$HALT = 1
FF		"HLT"		4
	1: 		00 		$PC:@O 				$HALT = 1

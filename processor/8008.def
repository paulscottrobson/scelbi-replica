// ***************************************************************************************************
//				Information from : 8008 Datasheet, Scelbi 8-H Users Manual Table 2.
// ***************************************************************************************************
//
//	@r 			ABCDEHLM on opcode shifted by step
//	@c 			conditions NC,NZ,P,PO,C,Z,M,PE
//	@t 			tests for @c
//	@v 			reset vector (2 digit hex)
//	@p 			port number (2 digit hex)
//
//	@fread 		as read but in step mode comes from switches
//	@read 		mem[mar] -> mbr
//	@write		mbr -> mem[mar]
//	@incpcmar	inc pc, copy to mar
//	@pushpc 	push pc on stack
//	@pullpc 	pull pc off stack
//	@branch 	npc -> pc
//
// ***************************************************************************************************
//							Load Data from One CPU Register to Another
// ***************************************************************************************************

C0-C6 	5 		"mov a,@r"
	1:00	[$pc,$mbr]		$a = $@r

C8-CE 	5 		"mov b,@r"
	1:00	[$pc,$mbr]		$b = $@r

D0-D6 	5 		"mov c,@r"
	1:00	[$pc,$mbr]		$c = $@r

D8-DE 	5 		"mov d,@r"
	1:00	[$pc,$mbr]		$d = $@r

E0-E6 	5 		"mov e,@r"
	1:00	[$pc,$mbr]		$e = $@r

E8-EE 	5 		"mov h,@r"
	1:00	[$pc,$mbr]		$h = $@r

F0-F6 	5 		"mov l,@r"
	1:00	[$pc,$mbr]		$l = $@r

// ***************************************************************************************************
//						Load Data from a CPU Register to a Location in Memory
// ***************************************************************************************************

F8-FE 	7 		"mov m,@r"
	1:** 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		$mbr = $@r;@write

// ***************************************************************************************************
//						Load Data from a Location in Memory to a CPU Register
// ***************************************************************************************************

C7-F7,8	8 		"mov @r,m"
	1:*0 	[@hl,$mbr] 		$mar = @hl
	2:00	[$pc,$mbr]		@read;$@r = $mbr

// ***************************************************************************************************
//								Load Immediate Data into a CPU register
// ***************************************************************************************************

06-36,8	8 		"mvi @r,#%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00	[$pc,$mbr]		@fread;$@r = $mbr

// ***************************************************************************************************
//							  Load Immediate Data to a location in memory
// ***************************************************************************************************

3E		9 		"mvi m,#%1"
	1:*0 	[$pc,$mbr] 		@incpcmar
	2:** 	[@hl,$mbr]		@read;$mar = @hl
	3:00 	[$pc,$mbr]		@fwrite

// ***************************************************************************************************
//								Increment or Decrement a CPU register
// ***************************************************************************************************

08-30,8	5		"inr @r"
	1:00	[$pc,$mbr] 		$@r = ($@r + 1) & 0xFF;$pszv = $@r

09-31,8	5		"dcr @r"
	1:00	[$pc,$mbr] 		$@r = ($@r - 1) & 0xFF;$pszv = $@r

// ***************************************************************************************************
//					Arithmetic operation between accumulator and CPU register
// ***************************************************************************************************

80-86	5 		"add @r"
	1:00	[$pc,$mbr] 		@add($@r,0);$a = $pszv

88-8E	5 		"adc @r"
	1:00	[$pc,$mbr] 		@add($@r,$carry);$a = $pszv
	
90-96	5 		"sub @r"
	1:00	[$pc,$mbr] 		@sub($@r,0);$a = $pszv

98-9E	5 		"sbc @r"
	1:00	[$pc,$mbr] 		@sub($@r,$carry);$a = $pszv

// ***************************************************************************************************
//							Compare between accumulator and CPU register
// ***************************************************************************************************

B8-BE	5 		"cmp @r"
	1:00	[$pc,$mbr] 		@sub($@r,0)

// ***************************************************************************************************
//				Arithmetic or Compare operation between accumulator and a word in memory
// ***************************************************************************************************

87		8		"add m"
	1:*0 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		@read;@add($mbr,0);$a = $pszv

8F		8		"adc m"
	1:*0 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		@read;@add($mbr,$carry);$a = $pszv

97		8		"sub m"
	1:*0 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		@read;@sub($mbr,0);$a = $pszv

9F		8		"sbb m"
	1:*0 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		@read;@sub($mbr,$carry);$a = $pszv

BF		8		"cmp m"
	1:*0 	[@hl,$mbr]		$mar = @hl
	2:00 	[$pc,$mbr]		@read;@sub($mbr,0)

// ***************************************************************************************************
//						Immediate type Arithmetic or Compare Instructions
// ***************************************************************************************************

04		8		"adi #%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00 	[$pc,$mbr]		@fread;@add($mbr,0);$a = $pszv

0C		8		"aci #%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00 	[$pc,$mbr]		@fread;@add($mbr,$carry);$a = $pszv

14		8		"sui #%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00 	[$pc,$mbr]		@fread;@sub($mbr,0);$a = $pszv

1C		8		"sbi #%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00 	[$pc,$mbr]		@fread;@sub($mbr,$carry);$a = $pszv

3C		8		"cpi #%1"
	1:*0 	[$pc,$mbr]		@incpcmar
	2:00 	[$pc,$mbr]		@fread;@sub($mbr,0)

// ***************************************************************************************************
//					Boolean math operation between accumulator and CPU register
// ***************************************************************************************************

A0-A6	5 		"and @r"
	1:00	[$pc,$mbr] 		$carry = 0;$a = $pszv = $a & $@r

A8-AE	5 		"xor @r"
	1:00	[$pc,$mbr] 		$carry = 0;$a = $pszv = $a ^ $@r

B0-B6	5 		"or @r"
	1:00	[$pc,$mbr] 		$carry = 0;$a = $pszv = $a | $@r

// ***************************************************************************************************
//				Boolean math operation between accumulator and a word in memory
// ***************************************************************************************************

A7		8		"and m"
	1:*0 	[@hl,$mbr]		$mar = @hl;$carry = 0
	2:00 	[$pc,$mbr]		@read;$a = $pszv = $a & $mbr

AF		8		"xor m"
	1:*0 	[@hl,$mbr]		$mar = @hl;$carry = 0
	2:00 	[$pc,$mbr]		@read;$a = $pszv = $a ^ $mbr

B7		8		"or m"
	1:*0 	[@hl,$mbr]		$mar = @hl;$carry = 0
	2:00 	[$pc,$mbr]		@read;$a = $pszv = $a | $mbr

// ***************************************************************************************************
//						Immediate type Arithmetic or Compare Instructions
// ***************************************************************************************************

24		8		"ani #%1"
	1:*0 	[$pc,$mbr]		@incpcmar;$carry = 0
	2:00 	[$pc,$mbr]		@fread;$a = $pszv = $a & $mbr

2C		8		"xri #%1"
	1:*0 	[$pc,$mbr]		@incpcmar;$carry = 0
	2:00 	[$pc,$mbr]		@fread;$a = $pszv = $a ^ $mbr

34		8		"ori #%1"
	1:*0 	[$pc,$mbr]		@incpcmar;$carry = 0
	2:00 	[$pc,$mbr]		@fread;$a = $pszv = $a | $mbr

// ***************************************************************************************************
//								Accumulator Rotate Instructions
// ***************************************************************************************************

02 		5 		"rlc"
	1:*0	[$pc,$mbr]		$carry = ($a >> 7) & 1;$a = (($a << 1) | $carry) & 0xFF

0A 		5 		"rrc"
	1:*0	[$pc,$mbr]		$carry = $a & 1;$a = ($a >> 1) | ($carry << 7)

12 		5 		"rlc"		$mar = ($a << 1) | $carry;$a = ($mar & 0xFF);$carry = ($mar >> 8) & 1
	1:*0	[$pc,$mbr]

1A 		5 		"rrc"		$mar = ($carry << 8) | $a;$carry = $mar & 1;$a = ($mar >> 1) & 0xFF
	1:*0	[$pc,$mbr]

// ***************************************************************************************************
//							Unconditional Jump and Call Instructions
// ***************************************************************************************************

44-7C,8	11 		"jmp %2"
	1:*0 	[$pc,$mbr] 		@incpcmar
	2:*0 	[$pc,$mbr]		@fread;@incpcmar;$npc = $mbr
	3:00	[$pc,$mbr]		@fread;@$npc = ($mbr << 8) | $npc;@branch

46-7E,8	11 		"call %2"
	1:*0 	[$pc,$mbr] 		@incpcmar
	2:*0 	[$pc,$mbr]		@fread;@incpcmar;$npc = $mbr
	3:00	[$pc,$mbr]		@fread;@$npc = ($mbr << 8) | $npc;@pushpc;@branch

// ***************************************************************************************************
//							Conditional Jump and Call Instructions
// ***************************************************************************************************

40-78,8	10 		"j@c %2"
	1:*0 	[$pc,$mbr] 		@incpcmar
	2:*0 	[$pc,$mbr]		@fread;@incpcmar;$npc = $mbr
	3:00	[$pc,$mbr]		@fread;@$npc = ($mbr << 8) | $npc;if (@t) { @branch; }

42-7A,8	10 		"c@c %2"
	1:*0 	[$pc,$mbr] 		@incpcmar
	2:*0 	[$pc,$mbr]		@fread;@incpcmar;$npc = $mbr
	3:00	[$pc,$mbr]		@fread;@$npc = ($mbr << 8) | $npc;if (@t) { @pushpc;@branch; }

// ***************************************************************************************************
//							Unconditional Return Instructions
// ***************************************************************************************************

07-3F,8	5 		"ret"
	1:00 	[$pc,$mbr]		@pullpc

// ***************************************************************************************************
//							 Conditional Return Instructions
// ***************************************************************************************************

03-3B,8	5 		"r@c"
	1:00 	[$pc,$mbr]		if (@t) { @pullpc; }

// ***************************************************************************************************
//									Restart Instruction
// ***************************************************************************************************

05-3D,8	5 		"rst @v"
	1:00 	[$pc,$mbr]		@pushpc;$npc = 0x@v;@branch


// ***************************************************************************************************
//									Output Instruction
// ***************************************************************************************************

51-7F,2	6 		"out @p"
	1:0*	[(0x@p << 8) | $a,$mbr]		
	2:00 	[$pc,$mbr]		$output@p($a)

// ***************************************************************************************************
//									 Input Instruction
// ***************************************************************************************************

41-4F,2	9 		"inp @p"
	1:0*	[(0x@p << 8) | $a,$mbr]		
	2:00 	[$pc,$mbr]		$a = $input@p()

// ***************************************************************************************************
//									  Halt Instruction
// ***************************************************************************************************

00-01	4 		"halt"
	1:00 	[($pc-1) & 0x3FFF,$mbr]	$halt = 1

FF	4 		"halt"
	1:00 	[($pc-1) & 0x3FFF,$mbr]	$halt = 1
